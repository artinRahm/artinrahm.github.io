// Create stars/particles
function createStars(): void {
    const starsContainer = document.querySelector('.stars');
    if (!starsContainer) return;

    const starCount = 50;
    for (let i = 0; i < starCount; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        star.style.animationDelay = `${Math.random() * 3}s`;
        star.style.animationDuration = `${2 + Math.random() * 3}s`;
        starsContainer.appendChild(star);
    }
}

// Theme management
let currentTheme = 'normal';
const themes = ['normal', 'black', 'green', 'red', 'rambo', 'ocean', 'sunset', 'neon', 'matrix', 'fire', 'ice', 'galaxy', 'gold', 'turbo', 'midnight'];

interface ThemeConfig {
    particle: string;
    line: string;
    speed: number;
}

const themeColors: Record<string, ThemeConfig> = {
    normal: { particle: 'rgba(177, 156, 217, 0.6)', line: '177, 156, 217', speed: 1 },
    black: { particle: 'rgba(255, 255, 255, 0.6)', line: '255, 255, 255', speed: 1 },
    green: { particle: 'rgba(144, 238, 144, 0.6)', line: '144, 238, 144', speed: 1 },
    red: { particle: 'rgba(255, 102, 102, 0.6)', line: '255, 102, 102', speed: 1 },
    rambo: { particle: 'rgba(255, 0, 0, 0.8)', line: '255, 0, 0', speed: 5 },
    ocean: { particle: 'rgba(0, 217, 255, 0.6)', line: '0, 217, 255', speed: 1.5 },
    sunset: { particle: 'rgba(255, 136, 68, 0.6)', line: '255, 136, 68', speed: 1.2 },
    neon: { particle: 'rgba(0, 255, 255, 0.8)', line: '0, 255, 255', speed: 2 },
    matrix: { particle: 'rgba(0, 255, 0, 0.7)', line: '0, 255, 0', speed: 2.5 },
    fire: { particle: 'rgba(255, 102, 0, 0.8)', line: '255, 102, 0', speed: 4 },
    ice: { particle: 'rgba(102, 204, 255, 0.6)', line: '102, 204, 255', speed: 0.8 },
    galaxy: { particle: 'rgba(255, 102, 255, 0.7)', line: '255, 102, 255', speed: 1.3 },
    gold: { particle: 'rgba(255, 215, 0, 0.7)', line: '255, 215, 0', speed: 1 },
    turbo: { particle: 'rgba(255, 255, 255, 0.9)', line: '255, 0, 255', speed: 8 },
    midnight: { particle: 'rgba(102, 153, 255, 0.6)', line: '102, 153, 255', speed: 1 }
};

// Particle system with mouse interaction
const canvas = document.getElementById('particle-canvas') as HTMLCanvasElement;
const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;
let particles: Particle[] = [];
const mouse = { x: null as number | null, y: null as number | null };
const connectionDistance = 150;
const particleCount = 80;

// Set canvas size
function resizeCanvas(): void {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Particle class
class Particle {
    x: number;
    y: number;
    baseVx: number;
    baseVy: number;
    radius: number;

    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.baseVx = (Math.random() - 0.5) * 0.5;
        this.baseVy = (Math.random() - 0.5) * 0.5;
        this.radius = Math.random() * 2 + 1;
    }

    update(): void {
        const speedMultiplier = themeColors[currentTheme].speed;
        this.x += this.baseVx * speedMultiplier;
        this.y += this.baseVy * speedMultiplier;

        // Wrap around edges
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height;
        if (this.y > canvas.height) this.y = 0;
    }

    draw(): void {
        ctx.fillStyle = themeColors[currentTheme].particle;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Initialize particles
for (let i = 0; i < particleCount; i++) {
    particles.push(new Particle());
}

// Animation loop
function animate(): void {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update and draw particles
    for (const particle of particles) {
        particle.update();
        particle.draw();

        // Draw line to mouse if close enough
        if (mouse.x !== null && mouse.y !== null) {
            const dx = mouse.x - particle.x;
            const dy = mouse.y - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const currentConnectionDistance = ['rambo', 'fire', 'turbo', 'neon'].includes(currentTheme) ? 250 : connectionDistance;
            if (distance < currentConnectionDistance) {
                const opacity = 1 - (distance / currentConnectionDistance);
                const lineOpacity = ['rambo', 'fire', 'turbo'].includes(currentTheme) ? opacity * 0.8 : opacity * 0.5;
                ctx.strokeStyle = `rgba(${themeColors[currentTheme].line}, ${lineOpacity})`;
                ctx.lineWidth = ['rambo', 'fire', 'turbo'].includes(currentTheme) ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(particle.x, particle.y);
                ctx.lineTo(mouse.x, mouse.y);
                ctx.stroke();
            }
        }
    }

    // Connect nearby particles to each other
    for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const particleConnectionDistance = ['rambo', 'fire', 'turbo'].includes(currentTheme) ? 150 : 100;
            if (distance < particleConnectionDistance) {
                const opacity = 1 - (distance / particleConnectionDistance);
                const lineOpacity = ['rambo', 'fire', 'turbo'].includes(currentTheme) ? opacity * 0.4 : opacity * 0.2;
                ctx.strokeStyle = `rgba(${themeColors[currentTheme].line}, ${lineOpacity})`;
                ctx.lineWidth = ['rambo', 'fire', 'turbo'].includes(currentTheme) ? 1.5 : 0.5;
                ctx.beginPath();
                ctx.moveTo(particles[i].x, particles[i].y);
                ctx.lineTo(particles[j].x, particles[j].y);
                ctx.stroke();
            }
        }
    }

    requestAnimationFrame(animate);
}
animate();

// Mouse trail effect
let mouseTrailTimeout: number | undefined;
document.addEventListener('mousemove', (e: MouseEvent) => {
    // Update mouse position for particle system
    mouse.x = e.clientX;
    mouse.y = e.clientY;

    // Throttle the trail creation
    if (mouseTrailTimeout) return;

    const throttleTime = ['rambo', 'fire', 'turbo', 'neon'].includes(currentTheme) ? 20 : 50;
    mouseTrailTimeout = window.setTimeout(() => {
        mouseTrailTimeout = undefined;
    }, throttleTime);

    // Create trail star
    const star = document.createElement('div');
    star.className = 'mouse-trail-star';
    star.style.left = `${e.clientX - 6}px`;
    star.style.top = `${e.clientY - 6}px`;

    document.body.appendChild(star);

    // Remove star after animation completes
    const removeTime = ['rambo', 'fire', 'turbo'].includes(currentTheme) ? 500 : 1500;
    setTimeout(() => {
        star.remove();
    }, removeTime);
});

// Update time
function updateTime(): void {
    const timeElement = document.getElementById('time');
    if (!timeElement) return;

    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const seconds = now.getSeconds().toString().padStart(2, '0');
    const ampm = hours >= 12 ? 'PM' : 'AM';
    const displayHours = hours % 12 || 12;

    timeElement.textContent = `${displayHours}:${minutes}:${seconds} ${ampm}`;
}

// Random online count variation
function updateOnlineCount(): void {
    const onlineElement = document.getElementById('online');
    if (!onlineElement) return;

    const baseCount = 1223;
    const variation = Math.floor(Math.random() * 10) - 5;
    onlineElement.textContent = `currently online: ${baseCount + variation}`;
}

// Show theme indicator
function showThemeIndicator(themeName: string): void {
    const indicator = document.getElementById('themeIndicator');
    if (!indicator) return;

    indicator.textContent = `theme: ${themeName}`;
    indicator.classList.add('show');

    setTimeout(() => {
        indicator.classList.remove('show');
    }, 2000);
}

// Open games page function
function openGamesPage(): void {
    const loadingGame = document.querySelector('loading-game');
    if (loadingGame) {
        loadingGame.classList.add('active');
        setTimeout(() => {
            loadingGame.classList.remove('active');
        }, 1000);
    }

    const newWindow = window.open('https://sites.google.com/view/cloveer/clovers-home', '_blank');
    if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
        window.location.href = 'https://sites.google.com/view/cloveer/clovers-home';
    }
}

// Open Discord function
function openDiscord(): void {
    const discordUrl = 'https://discord.gg/aQ8YSn79xQ';
    const newWindow = window.open(discordUrl, '_blank');
    if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
        window.location.href = discordUrl;
    }
}

// Open Steam profile function
function openSteamProfile(): void {
    const steamUrl = 'https://steamcommunity.com/profiles/76561199703728458/';
    const newWindow = window.open(steamUrl, '_blank');
    if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
        window.location.href = steamUrl;
    }
}

// Open GitHub profile function
function openGitHubProfile(): void {
    const githubUrl = 'https://github.com/artinRahm';
    const newWindow = window.open(githubUrl, '_blank');
    if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
        window.location.href = githubUrl;
    }
}

// Open Apps page function
function openAppsPage(): void {
    const appsUrl = 'https://gn-math.github.io/';
    const newWindow = window.open(appsUrl, '_blank');
    if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
        window.location.href = appsUrl;
    }
}

// Change theme function
function changeTheme(): void {
    const currentIndex = themes.indexOf(currentTheme);
    const nextIndex = (currentIndex + 1) % themes.length;
    const nextTheme = themes[nextIndex];

    // Remove current theme class
    if (currentTheme !== 'normal') {
        document.body.classList.remove(`theme-${currentTheme}`);
    }

    // Add new theme class
    if (nextTheme !== 'normal') {
        document.body.classList.add(`theme-${nextTheme}`);
    }

    // Add more particles for fast themes
    if (['rambo', 'fire', 'turbo', 'neon'].includes(nextTheme) && !['rambo', 'fire', 'turbo', 'neon'].includes(currentTheme)) {
        const extraParticles = nextTheme === 'turbo' ? 150 : 120;
        for (let i = 0; i < extraParticles; i++) {
            particles.push(new Particle());
        }
    }
    // Remove extra particles when leaving fast themes
    else if (['rambo', 'fire', 'turbo', 'neon'].includes(currentTheme) && !['rambo', 'fire', 'turbo', 'neon'].includes(nextTheme)) {
        particles = particles.slice(0, particleCount);
    }

    // Update current theme
    currentTheme = nextTheme;

    // Save theme preference
    localStorage.setItem('selectedTheme', currentTheme);

    // Show theme indicator
    showThemeIndicator(currentTheme);
}

// Load saved theme on page load
function loadTheme(): void {
    const savedTheme = localStorage.getItem('selectedTheme');
    if (savedTheme && themes.includes(savedTheme)) {
        currentTheme = savedTheme;
        if (currentTheme !== 'normal') {
            document.body.classList.add(`theme-${currentTheme}`);
        }
        // Add extra particles for fast themes
        if (['rambo', 'fire', 'turbo', 'neon'].includes(currentTheme)) {
            const extraParticles = currentTheme === 'turbo' ? 150 : 120;
            for (let i = 0; i < extraParticles; i++) {
                particles.push(new Particle());
            }
        }
    }
}

// Setup event listeners
document.addEventListener('DOMContentLoaded', () => {
    loadTheme();
    createStars();
    updateTime();
    updateOnlineCount();

    // Games link in sidebar
    const gamesLink = document.getElementById('games-link');
    if (gamesLink) {
        gamesLink.addEventListener('click', (e) => {
            e.preventDefault();
            openGamesPage();
        });
    }

    // Center game icon
    const centerGameIcon = document.getElementById('center-game-icon');
    if (centerGameIcon) {
        centerGameIcon.addEventListener('click', (e) => {
            e.preventDefault();
            openGamesPage();
        });
    }

    // User/Steam icon
    const userIcon = document.getElementById('user-icon');
    if (userIcon) {
        userIcon.addEventListener('click', (e) => {
            e.preventDefault();
            openSteamProfile();
        });
    }

    // Discord icon
    const discordIcon = document.getElementById('discord-icon');
    if (discordIcon) {
        discordIcon.addEventListener('click', (e) => {
            e.preventDefault();
            openDiscord();
        });
    }

    // Open blank button
    const openBlankBtn = document.getElementById('openblank');
    if (openBlankBtn) {
        openBlankBtn.addEventListener('click', (e) => {
            e.preventDefault();
            window.open('https://sites.google.com/view/cloveer/clovers-home', '_blank');
        });
    }

    // Fullscreen button
    const fullscreenBtn = document.getElementById('fullscreen');
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', (e) => {
            e.preventDefault();

            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch((err) => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        });
    }

    // User profile button (GitHub)
    const userProfileLink = document.getElementById('user-profile-link');
    if (userProfileLink) {
        userProfileLink.addEventListener('click', (e) => {
            e.preventDefault();
            openGitHubProfile();
        });
    }

    // Settings button (Theme switcher)
    const settingsLink = document.getElementById('settings-link');
    if (settingsLink) {
        settingsLink.addEventListener('click', (e) => {
            e.preventDefault();
            changeTheme();
        });
    }

    // Apps button
    const appsLink = document.getElementById('apps-link');
    if (appsLink) {
        appsLink.addEventListener('click', (e) => {
            e.preventDefault();
            openAppsPage();
        });
    }

    // Update time every second
    setInterval(updateTime, 1000);

    // Randomly update online count every 10 seconds
    setInterval(updateOnlineCount, 10000);
});
